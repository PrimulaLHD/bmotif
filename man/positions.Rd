% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/positions.R
\name{positions}
\alias{positions}
\title{Calculate node position vectors}
\usage{
positions(M, six_node, level = "all", normalisation = "none")
}
\arguments{
\item{M}{A numeric matrix representing interactions between two groups of nodes. Each row corresponds to a node in one level
and each column corresponds to a node in the other level. Elements of M are positive numbers if nodes do interact, and 0
otherwise. Formally, M is an incidence matrix. When nodes i and j interact, m_ij > 0; if they do not interact, m_ij = 0.
If interactions are weighted (non-zero matrix elements can take values greater than 1), the function will automatically convert the matrix to a binary
matrix.}

\item{six_node}{Logical; should six node motifs be counted?}

\item{level}{Which node level should positions be calculated for: \code{rows}, \code{columns} or \code{all}?  Defaults to \code{all}.}

\item{normalisation}{Which normalisation should be used: \code{none}, \code{across} or \code{within}?  Defaults to \code{none}.}
}
\value{
By default, returns a data frame with 46 columns, one for each motif position. If \code{six_node} is TRUE, there will be 144 columns (one for each position).
For a network with A rows and P columns, by default (where \code{level} = "all") the data frame has A + P rows, one for each node. If \code{level} = "rows", the data frame will have A rows, one for each row node;
if \code{level} = "columns", it will have P rows, one for each column node.

By default, the elements of this data frame will be the raw position counts. If \code{normalisation} is set to "within" or "across", the elements will be
the normalised position counts.
}
\description{
Counts the number of times each node in a network occurs in each of the 46 positions found within the 17 motifs up to five nodes
}
\details{
The \code{level} argument controls which node group positions are calculated for. \code{rows} returns position counts for all nodes in rows, \code{columns}
returns counts for all nodes in columns, and \code{all} return counts for all nodes in the network.

Nodes with more interactions will tend to appear in more positions. Normalisation helps control for this.
\code{none} performs no normalisation and will return the raw position counts.
\code{across} divides position counts for each node by the total number of times that node appears in any position.
\code{within} divides position counts for each node by the total number of times that node appears in any position within the same motif size class.

Warning: including six node motifs is fine for most networks. However, for large networks, counting six node motifs can be slow and memory intensive. In some cases, R can crash if there is not enough memory.
}
\examples{
set.seed(123)
row <- 15
col <- 15
m <- matrix(sample(0:1, row*col, replace=TRUE), row, col)
positions(M = m, six_node = TRUE, level = "all", normalisation = "none")
}

