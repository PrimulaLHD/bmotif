% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roles.R
\name{roles}
\alias{roles}
\title{Compute node structural roles}
\usage{
roles(M, level = "all", normalisation = "none")
}
\arguments{
\item{M}{A numeric matrix representing interactions between two groups of nodes. Each row corresponds to a node in one level
and each column corresponds to a node in the other level. Elements of M are positive numbers if nodes do interact, and 0
otherwise. Formally, M is an incidence matrix. When nodes i and j interact, m_ij > 0; if they do not interact, m_ij = 0.
If interactions are weighted (non-zero matrix elements can take values greater than 1), the function will automatically convert the matrix to a binary
matrix.}

\item{level}{Which node level should roles be calculated for: \code{rows}, \code{columns} or \code{all}?  Defaults to \code{all}.}

\item{normalisation}{Which normalisation should be used: \code{none}, \code{across} or \code{within}?  Defaults to \code{none}.}
}
\value{
\code{roles} returns a data frame with 46 columns, one for each motif position.
For a network with A rows and P columns, by default (where \code{level} = "all") the data frame has A + P rows, one for each node. If \code{level} = "rows", the data frame will have A rows, one for each row node;
if \code{level} = "columns", it will have P rows, one for each column node.

By default, the elements of this data frame will be the raw position counts. If \code{normalisation} is set to "within" or "across", the elements will be
the normalised position counts.
}
\description{
Counts the number of times each node in a network occurs in each of the 46 positions found within the 17 motifs up to five nodes
}
\details{
The \code{level} argument controls which node's group roles are calculated for. \code{rows} returns position counts for all nodes in rows, \code{columns}
returns counts for all nodes in columns, and \code{all} return counts for all nodes in the network.

Nodes with more interactions will tend to appear in more positions. Normalisation helps control for this.
\code{none} performs no normalisation and will return the raw position counts.
\code{across} divides position counts for each node by the total number of times that node appears in any position.
\code{within} divides position counts for each node by the total number of times that node appears in any position within the same motif size class.
Which normalisation is most appropriate will depend on the question being asked.
}
\examples{
set.seed(123)
row <- 100
col <- 100
m <- matrix(sample(0:1, row*col, replace=TRUE), row, col)
roles(M = m, level = "all", normalisation = "none")
}

